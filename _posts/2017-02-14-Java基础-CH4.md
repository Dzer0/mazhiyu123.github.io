---
published: true
layout: post
title: Java基础-CH4
category: Java
tags: 
  - Java
time: 2017.02.14 21:31:00
excerpt: 强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
---

1. java内部类总结  
1)在方法间定义的非静态内部类：   
    外围类和内部类可互相访问自己的私有成员。  
    内部类中不能定义静态成员变量。  
    在外部类作用范围之外向要创建内部类对象必须先创建其外部类对象  

    2)在方法间定义的静态内部类：  
    只能访问外部类的静态成员。  
    静态内部类没有了指向外部的引用  

    3)在方法中定义的局部内部类：  
    该内部类没有任何的访问控制权限  
    外围类看不见方法中的局部内部类的，但是局部内部类可以访问外围类的任何成员。  
    方法体中可以访问局部内部类，但是访问语句必须在定义局部内部类之后。  
    局部内部类只能访问方法体中的常量，即用final修饰的成员。  

    4)在方法中定义的匿名内部类：  
    没有构造器，取而代之的是将构造器参数传递给超类构造器  
    当你只需要创建一个类的对象而且用不上它的名字时，使用匿名内部类可以使代码看上去简洁清楚。  

String两种实例化方式：
```
String str = “abc”；
String str = new String("abc");
```
一个字符串就是String的匿名对象。
"hello".equals(str)    一个字符串能够调用一个函数，可以看出，一个字符串是String的匿名对象。

2. 动态类型语言 动态语言 弱类型语言  
强类型定义语言和弱类型定义语言  
（1）强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。  
（2）弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。
强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！
例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。   
无类型： 汇编  
弱类型、静态类型 ： C/C++  
弱类型、动态类型检查： Perl/PHP  
强类型、静态类型检查 ：Java/C#  
强类型、动态类型检查 ：Python, Scheme  
静态显式类型 ：Java/C  
静态隐式类型 ：Ocaml, Haskell  

3. Java assert  
assert <boolean表达式>
  如果<boolean表达式>为true，则程序继续执行。
  如果为false，则程序抛出AssertionError，并终止执行。
 
    assert <boolean表达式> : <错误信息表达式>
  如果<boolean表达式>为true，则程序继续执行。
  如果为false，则程序抛出java.lang.AssertionError，并输入<错误信息表达式>。  
  
4. 构造函数没有返回值，不同于返回值为空

5. 泛型一个局限性。基本类型无法作为类型参数

6. 方法重载，同样的函数名字，不同的形参类型，个数。返回不同值不能作为不同方法的标志，参数顺序不同也可以，但是不建议这么做会使程序变得难以理解  

7. static方法就是没有this的方法  
      在没有创建任何对象的前提下，仅仅通过类本身就可以调用static方法  
 
8. Java程序主类需要构造函数吗？
可以定义也可以不定义  

9. 构造函数没有返回值，不同于返回值为空  

10. 泛型一个局限性。基本类型无法作为类型参数  

11. 方法重载，同样的函数名字，不同的形参类型，个数。返回不同值不能作为不同方法的标志，参数顺序不同也可以，但是不建议这么做会使程序变得难以理解  

12. static方法就是没有this的方法  
      在没有创建任何对象的前提下，仅仅通过类本身就可以调用static方法
      
13. 方法内联 常量传播 窥孔优化  
内联函数  
在说内联函数之前，先说说函数的调用过程。         调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到 转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保 存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体 代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大.   那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。内联函数就是在程序编译时，编译器将程序中出现 的内联函数的调用表达式用内联函数的函数体来直接进行替换。显然，这样就不会产生转去转回的问题，但是由于在编译 时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时 那么大，可见它是以目标代码的增加为代价来换取时间的节省。       在大学里学习写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用 到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的 处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等）     写过C++代码的应该都知道，在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被 编译器视为内联函数
C++是否为内联函数由自己决定，Java由编译器决定。  
Java不支持直接声明为内联函数的，如果想让他内联，则是由编译器说了算，你只能够向编译器提出请求。  
final除了不能被override外，还可能实现内联。  
如果函数为private，则也可能是内联的。
总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数。

常量传播：  
这个"常量折叠"就是在编译器进行语法分析的时候，将常量表达式计算求值，并用求得的值来替换表达式，放入常量表。可以算作一种编译优化。  
而下面代码的比较也会相等：
```
public class StringConstant {
 public static void main(String[] args) {
 String a ="123"+"456";
 String b ="12"+ 3456;
 System.out.println(a == b); // true
}
}
```
即便混搭了字符串与数字的运算也没关系。
在.class 文件中a=123456;.....b=123456;

14. 类库中有没有抽象类？继承抽象类必须实现所有方法。。  有

15. 字节码->方法内联、常量传播等->HIR（SSA）->空值检查消除、数组边界检查消除等->优化后的HIR->LIR->寄存器分配、窥孔优化->机器码生成->本地代码

16. 锁和对象的关系 同步中锁是任意对象  ？  
假设我有一个类ClassA，其中有一个方法synchronized methodA()，那么当这个方法被调用的时候你获得就是对象锁，但是要注意，如果这个类有两个实例，比如：ClassA a = new ClassA();ClassA b = new ClassA();那么如果你在a这对象上调用了methodA，不会影响b这个对象，也就是说对于b这个对象，他也可以调用methodA，因为这是两对象，所以说对象锁是针对对象的。而类锁，其实没有所谓的类锁，因为类锁实际上就是这个类的对象的对象锁，还是举例，我有一个类ClassA，其中有一个方法synchronized static methodA()，注意这个方法是静态的了，那就是说这个类的所有的对象都公用一个这个方法了，那如果你在这个类的某个对象上调用了这个方法，那么其他的对象如果想要用这个方法就得等着锁被释放，所以感觉就好像这个类被锁住了一样。  

17. Java强引用，弱引用  
StringBuffer buffer=new StringBuffer();创建对象并将对象的（强）引用赋值给buffer。
弱引用：就是将对象留在内存的能力不是那么强的引用。使用弱引用垃圾回收器会帮助你决定引用的对象何时被收回。

    创建弱引用：
WeakReference<Widget> weakWidget=new WeakReference<Widget>(widget);
weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现使用get时突然返回null.一旦弱引用对象开始返回null，该弱引用就被标记成了垃圾。而这个弱引用（不是其指向的对象）就没有什么用了。
WeakHashMap.

18. Java中有四种引用，从强到弱。。。强引用》软引用》弱引用》虚引用。

引用队列(Reference Queue)  
一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。
引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对 象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有 用的引用对象。

软引用（Soft Reference）  
软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾 回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对 象。
由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。

虚引用 （Phantom Reference）  
与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。  
当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对 象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方 法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。
虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大 文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错 误。  
第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了 finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在 析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象 的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会 出现烦人的内存溢出错误。
使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。  
显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。  

19. hashcode值 equals()方法?  
Java中的equals方法和hashCode方法是Object中的，所以每个对象都是有这两个方法的，有时候我们需要实现特定需求，可能要重写这两个方法，今天就来介绍一些这两个方法的作用。  
equals()和hashCode()方法是用来在同一类中做比较用的，尤其是在容器里如set存放同一类对象时用来判断放入的对象是否重复。
Java系统首先调用对象的hashCode()方法获得该对象的哈希码表，然后根据哈希吗找到相应的存储区域，最后取得该存储区域内的每个元素与该对象进行equals方法比较；  
如果obj1.equals(obj2)的结果为true,那么以下表达式的结果也要为true:  
obj1.hashCode() == obj2.hashCode()  
换句话说：当我们重写一个对象的equals方法，就必须重写他的hashCode方法，不过不重写他的hashCode方法的话，Object对象中的hashCode方法始终返回的是一个对象的hash地址，而这个地址是永远不相等的。所以这时候即使是重写了equals方法，也不会有特定的效果的，因为hashCode方法如果都不想等的话，就不会调用equals方法进行比较了，所以没有意义了。  
equals（）方法：依次类推Double、Integer、Math。。。。等等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然了基本类型是进行值的比较，这个没有什么好说的。  
我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：  
• 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。  
• 反射性：x.equals(x)必须返回是“true”。  
• 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。  
• 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。  
• 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。  
以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守 。  
equals（）和==的区别  
值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。  
分成基本数据和对象讨论

******* |  基本数据 |     对象 
--------|-----------|--------
＝＝      |   值    |     引用
equals     |  无     |     值
基本数据是存储在堆栈中  
对象存储在动态堆中  

java中的数据类型，可分为两类  
    1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean 
  他们之间的比较，应用双等号（= =）,比较的是他们的值。   
    2.复合数据类型(类)   
  当他们用（= =）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false     JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。  
  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（= =）进行比较的，所以比较后的结果跟双等号（= =）的结果相同。
hashCode（）的实现是根据本地机器相关的。

20. 构造函数。。。。  
public MaxPQ(){
 this(1);//调用父类构造函数并传入参数1.
}
  
21. Class 对象  
Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。  
      Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。  
      虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。  
      基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。  
      每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。  
      一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。  
一、如何得到Class的对象呢？有三种方法可以的获取：  
    1、调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：  
    ```
    MyObject x;
    Class c1 = x.getClass();  
    ```  
    2、使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如：  
    ```
    Class c2=Class.forName("MyObject")
    ```  
    Employee必须是接口或者类的名字。   
    3、获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如  
    ```
    Class cl1 = Manager.class;
    Class cl2 = int.class;
    Class cl3 = Double[].class;
    ```  
    注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。
      
    二、Class类的常用方法  
    1、getName()   
    一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。  
    2、newInstance()  
    Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如：
    x.getClass.newInstance()，创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象。  
    3、getClassLoader()   
    返回该类的类加载器。  
    4、getComponentType()   
    返回表示数组组件类型的 Class。  
    5、getSuperclass()   
    返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。  
    6、isArray() 
    判定此 Class 对象是否表示一个数组类。  
三、Class的一些使用技巧  
    1、forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象。例如
    Object obj = Class.forName(s).newInstance();
    2、虚拟机为每种类型管理一个独一无二的Class对象。因此可以使用==操作符来比较类对象。例如：
    if(e.getClass() == Employee.class)...

22. 对象的串行访问
    多个线程依次以独占的方式访问对象，而不是并发的访问。
    
23. 对象的序列化  
当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。  
　　只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。  
1.概念  
　　序列化：把Java对象转换为字节序列的过程。  
　　反序列化：把字节序列恢复为Java对象的过程。  
2.用途  
　　对象的序列化主要有两种用途：  
　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；  
　　2） 在网络上传送对象的字节序列。  


24. A实现了接口B，B继承自C。是否可以说A继承了C? 是

25. private public protected 默认 访问的范围   
Java中访问修饰符public、private、protecte、default的意义讲解
public（接口访问权限）：   Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。    
private（你无法访问）:   Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。  
protected（继承访问权限）: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。  
default（包访问权限）：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 

******|类内部|本包|子类|外部包
------|----|----|------|-----
public| √	| √	| √	| √  
protected	| √	| √	| √	| ×  
default 	| √	| √	| ×	| ×  
 private	| √	| ×	| ×	| × 
 
26. 接口是可以继承自接口的，如： 
```
public interface Collection<E> extends Iterable<E> {}  
而public interface Iterator<E> {}  
```
27. 泛型类  当声明一个泛型类时则包含一个或者多个类型参数。放在类名后面的尖括号里<>.  
```
public class GenericMemoryCell<AnyType>
{
    private AnyType storedValue;

    public AnyType read(){return storedValue;}
    public                write(AnyType x){storedValue=x;}
```
28. 接口是泛型的
```
package java.lang
    public interface Comparable<AnyType>
{
    public int compareTo(AnyType other);
}
```
29. Java中数组是协变的，泛型集合不是协变的。  
Number[] num = new Integer[10]; num[0] = 2.1;   
这样的语句可以通过编译，而在运行时会错误。  
协变性：如果类Base是类Sub的基类，那么Base[]就是Sub[]的基类。  
而泛型是不可变的(invariant)，List<Base>不会是List<Sub>的基类，更不会是它的子类。  
通配符用来表示参数类型的子类<? extends A>（参数类型需要时A或A的子类）或者超类<? super A>（参数类型需要A或A的超类）。  

30. 方法是泛型的  
public <Anytype> boolean fun(AnyType[] arr,AnyType x){};
当使用泛型类的时候在创建类对象的时候必须指定参数类型的值.而使用泛型方法的时候不必这样做.因为,编译器会为我们找到具体的类型,此为类型参数推断.

31. 泛型中 ? super T和? extends T 的区别？  

经常发现有List<? super T>、Set<? extends T>的声明，是什么意思呢？<? super T>表示包括T在内的任何T的父类，<? extends T>表示包括T在内的任何T的子类，下面我们详细分析一下两种通配符具体的区别。
```
extends

List<? extends Number> foo3的通配符声明，意味着以下的赋值是合法的：
// Number "extends" Number (in this context)
 
List<? extends Number> foo3 = new ArrayList<? extends Number>();
 
// Integer extends Number
 
List<? extends Number> foo3 = new ArrayList<? extends Integer>();
 
// Double extends Number
 
List<? extends Number> foo3 = new ArrayList<? extends Double>();
```
读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的类元素。你不能保证读取到Integer，因为foo3可能指向的是List<Double>。你不能保证读取到Double，因为foo3可能指向的是List<Integer>。  
写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你不能插入一个Integer元素，因为foo3可能指向List<Double>。你不能插入一个Double元素，因为foo3可能指向List<Integer>。你不能插入一个Number元素，因为foo3可能指向List<Integer>。你不能往List<? extends T>中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。  
```
super

现在考虑一下List<? super T>。
List<? super Integer> foo3的通配符声明，意味着以下赋值是合法的：
// Integer is a "superclass" of Integer (in this context)
 
List<? super Integer> foo3 = new ArrayList<Integer>();
 
// Number is a superclass of Integer
 
List<? super Integer> foo3 = new ArrayList<Number>();
 
// Object is a superclass of Integer
 
List<? super Integer> foo3 = new ArrayList<Object>();
```
读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你不能保证读取到Integer，因为foo3可能指向List<Number>或者List<Object>。你不能保证读取到Number，因为foo3可能指向List<Object>。唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。  
写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。你不能插入Double对象，因为foo3可能指向ArrayList<Integer>。你不能插入Number对象，因为foo3可能指向ArrayList<Integer>。你不能插入Object对象，因为foo3可能指向ArrayList<Integer>。  

PECS

请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。  
生产者使用extends  
如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成<? extends T>，比如List<? extends Integer>，因此你不能往该列表中添加任何元素。  
消费者使用super  
如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成<? super T>，比如List<? super Integer>，因此你不能保证从中读取到的元素的类型。  
即是生产者，也是消费者
如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List<Integer>。
例子

请参考java.util.Collections里的copy方法(JDK1.7)：

我们可以从Java开发团队的代码中获得到一些启发，copy方法中使用到了PECS原则，实现了对参数的保护。

32. Java在运行时创建实例  

33. Java基本类型不能用作类型参数的值.必须使用他们的包装类.  
instanceof检测和类型转换只对原始类型进行.I/O.

34. Java对象的序列化，Java对象的持久化？    
序列化 :  把对象转换   为二进制数据(如网络传输,存储数据库等),必须实现序列化接口 (java.io.Serializable).  
        持久化 :  把对象保存 在介质上(如写文件,读文件不是), 没有接口实现,一般指方法调用.  
如果按照存储介质和生命周期的长短划分，所有的数据都以两种形式存在，其中一种是保存于内存中的运行时对象，另一种则是存储于持久化物理介质中的文件，比如数据库文件等。数据的持久化关注于相同的数据在不同形态数据之间的转化，解决的是如何将内存对象持久化存储，以及从物理介质中加载数据并创建内存对象。  
数据的持久化是序列化的又一个典型的应用，对象只有在序列化之后才能进行持久化存储，从持久化存储介质加载的数据通过反序列化转变成运行时对象。  

35. Java中覆盖和隐藏的区别？  
main方法也是可以被重载的  
子类实例方法不能覆盖父类的静态方法；子类的静态方法也不能覆盖父类的实例方法(编译时报错)，总结为方法不能交叉覆盖
隐藏：父类和子类拥有相同名字的属性或者方法时，父类的同名的属性或者方法形式上不见了，实际是还是存在的.
　　   
　　 注意：当发生隐藏的时候，声明类型是什么类，就调用对应类的属性或者方法，而不会发生动态绑定方法隐藏只有一种形式，就是父类和子类存在相同的静态方法属性只能被隐藏，不能被覆盖子类实例变量/静态变量可以隐藏父类的实例/静态变量，总结为变量可以交叉隐藏
　　
隐藏和覆盖的区别：  
　　被隐藏的属性，在子类被强制转换成父类后，访问的是父类中的属性  
　　被覆盖的方法，在子类被强制转换成父类后，调用的还是子类自身的方法  
　　因为覆盖是动态绑定，是受RTTI(run time type identification，运行时类型检查)约束的，隐藏不受RTTI约束，总结为RTTI只针对覆盖，不针对隐藏   
特殊情况：  
　　1.final修饰的属性可以被隐藏，但是不能被赋值，即不能用=来赋值，网上说final属性不能被修改，这个说法不准确，因为对于引用类型的变量用final修饰后，它只是不能被指向其他对象，但是可以改它自身的值，可以用ArrayList测试，final属性可以在运行的时候进行初始化，但是不能不出现初始化语句  
　　2.final修饰的方法不能被覆盖，可以被重载  
　　3.final修饰的类不能被继承  
　　4.private 方法隐式添加了final  
　　

36. Java中，Reader是用于读取字符流抽象类，Reader/Writer只处理Unicode字符的输入输出。InputStream提供的是字节流的读取 ，而非文本读取。  
用Reader读取出来的是char数组或者String，使用InputStream读取出来的是byte数组。float和double可以通过stream进行I/O.  

37. Java中传值传引用的问题？  
Java确实使用对象的引用来做计算的，所有的对象变量都是引用。但是，Java在向方法传递参数时传的不是引用，是值。
以 badSwap() 函数为例:  

```
public void badSwap(int var1, int var2)
{
    int temp = var1;
    var1 = var2;
    var2 = temp;
}
```
当badSwap方法返回时，被当作参数传入的变量仍然保持了原来的值不变。如果我们把传入的int型变量改为Object型也是一样的，因为Java通过传值来传递引用的。  

```
public void tricky(Point arg1, Point arg2)  
{  
    arg1.x = 100;  
    arg1.y = 100;  
    Point temp = arg1;  
    arg1 = arg2;  
    arg2 = temp;  
}  
 
public static void main(String [] args)
{
    Point pnt1 = newPoint(0,0);
    Point pnt2 = newPoint(0,0);
    System.out.println("X: "+ pnt1.x + " Y: "+pnt1.y);
    System.out.println("X: "+ pnt2.x + " Y: "+pnt2.y);
    System.out.println(" ");
    tricky(pnt1,pnt2);
    System.out.println("X: "+ pnt1.x + " Y:"+ pnt1.y);
    System.out.println("X: "+ pnt2.x + " Y: "+pnt2.y);
}

执行这个函数,将得到以下输出:
———————————————————-
X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
———————————————————-
``` 

即使是通过值传递，tricky函数依然成功地改变了pnt1的值。但是pnt1和pnt2的置换失败了。这正是最令人困惑的地方。在main()函数当中，pnt1和pnt2仅仅是对象的引用。当你向tricky()函数传递pnt1和pnt2参数时，Java仅仅向传递任何其他参数一样，通过传值来传递引用。这就意味着：传向函数的引用实际上是原始引用的副本。  
Java复制并传递了“引用”的值，而不是对象。因此，方法中对对象的计算是会起作用的，因为引用指向了原来的对象。但是因为方法中对象的引用是“副本”，所以对象交换就没起作用。如图2所示，交换动作只对方法中的引用副本起作用了，不影响方法外的引用。所以不好意思，方法被调用后，改变不了方法外的对象的引用。如果要对方法外的对象引用做交换，我们应该交换原始的引用，而不是它的副本。
 
