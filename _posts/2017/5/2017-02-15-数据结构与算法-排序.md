---
published: true
layout: post
title: 数据结构与算法-排序
category: 数据结构与算法
tags: 
  - 数据结构与算法
time: 2017.02.15 17:50:00
excerpt: 先进行一遍冒泡排序，将最小的元素放到第一位，并记录元素交换次数，如果为零，则有序。有序段和无序段，先将无序段的第一个元素保存到临时变量，然后从它开始向前比较，直到找打它应该在的位置，然后将临时变量的值赋值过去。。。以此类推这样可以减少元素交换的次数。  
---

1. 选择排序（selection-sort）  
可以分为有序段和无序段  
在无序段的数中选出最小的数放到有序段中的最后一个数中  
第一遍可找到最小（最大）的数，第二篇找到第二小（大 ）的数，以此类推。  
每一次都将各个数字放到了它应该在的位置。  

2. 插入排序（insertion-sort）  
同样可以分为有序段和无序段  
将无序段的第一个数，依次向前翻直到遇到比它小（大）的数，  

    改进：  
    先进行一遍冒泡排序，将最小的元素放到第一位，并记录元素交换次数，如果为零，则有序。  
   有序段和无序段，先将无序段的第一个元素保存到临时变量，然后从它开始向前比较，直到找打它应该在的位置，然后将临时变量的值赋值过去。。。以此类推  
   这样可以减少元素交换的次数。  


3. 希尔排序（shell-sort）  
又叫缩小增量排序，缩小增量直到1，其中增量之间可以用插入排序。  

4. 归并排序（merge-sort）  
 是将两个有序的数据段，归并的一起。  

    1. 原地归并：  
         待排序数组分为左有序右有序两段，将待排序的数组复制到临时数组中，然后从临时数组中向回归并。这个是其他归并的基础操作，和N成正比的空间复杂度。  
    2. 递归归并（自顶向下的）  
        采用了递归的方式，体现了分治的思想，大数组分为小数组。    
        程序结构 
         
        ```            
        在sort外面开辟辅助数组；
            sort（）{
                。。。。
                sort左；
                sort右；
                merge（）
            }

            merge（）{
                对辅助数组中相应数据段初始化；//并非一开始就全部初始化。

                for（lo到hi）{
                    左结束//连着的if else
                    右结束
                    左小右
                    右小左
                }  
            }
        ```
    改进1：基于递归并，对小的子数组可以用插入排序（hi-lo<规定的一个恰当的值）；  

    3. 自底向上的归并（非递归，循环）快速  
          由小数组归并到大数组  
          for控制着归并数组的大小。多趟遍历数组。  

5. 快速排序（quick-sort）  
    找到一个哨兵元素（可以是第一个最后一个或者随机一个），左边的元素小于哨兵元素，右边的元素大于烧饼元素。然后再左右把两边分别进行找哨兵元素移动元素，直到一个元素为一组时结束。  
    每一趟快排都有元素找到他最后应该在的位置。  
    程序结构   
    ```
        sort（）{
            j=partition(....)
            sort(lo...j)
            sort(j+1...hi);
        }
            
        partition(.....){
            while（）{
                while（）找到左边第一个小于哨兵元素的==i
                while（）找到右边第一个大于哨兵元素的==j
                if（i>=j）结束
                exch（i，j）
            }
            
            exch（哨兵元素，j或i）//j或者i对应着取不同的哨兵元素（j哨兵元素是第一个，i哨兵元素是最后一个）
            return j;
        }
        
    ```
        
    改进1：  
    当子数组变得很小的时候，快排的效率是不如插入排序的。因为递归，小数组在排序的时候也是调用快排的sort（）；  
    可以设置一个界限M，当子数组的大小小于M的时候就不用快排了而是改用插入排序（通常M取5-15之间的任意值是一个令人满意的效果）；  
    
    改进2：  
    切分的哨兵元素，最好是中位数，代价是需要计算中位数。一般情况下，在数组中取样的大小为3，然后取中间的数作为中位数效果还可以。  
    还可以将哨兵元素放到最后面，或者将最后的元素设置为哨兵，此时可以不用进行边界检查。（需要实现一下）  
      
    改进3：  
    （适合于大量重复元素）运行时可以设置三个指针将数据元素分为四个部分，  
        （1）lo到lt为小于哨兵元素v的  
        （2）lt到i为等于哨兵v的  
        （3）i到gt为还没有进行排序的  
        （4）gt到hi为大于哨兵v的  
        程序结构  
    ```
        sort(。。。。。) {
            遍历一遍后将数组分为小于，等于，大于v的三个部分。
            sort（a,lo,lt）;
            sort(a,gt,hi);          //在lt到gt之间的元素为等于v的，不对它们进行递归调用；
    }
    ```     

6. 优先队列  
    优先队列可以用数组，链表等结构实现。这里采用完全二叉树。  
    完全二叉树中，节点k的左右孩子分别为2*k和2*k+1，节点k的父节点为（2/k）向下取整；  
    完全三叉树中，节点k的左中右孩子为3*k-1，3*k，3*k+1，节点k的父节点为（k/3）向下取整；  
    在构造优先队列的时候需要上浮swim（）和下沉sink（）操作。其实就是比较父子元素，然后交换。针对单个元素的操作；  
    插入元素时需要上浮，（将元素放到数组的末尾然后一步步上浮到合适的位置）；  
    删除元素是需要下称，（删除最大（最小）元素然后和最后一个元素交换，删除，调整堆）；   
    索引优先队列？  

7. 堆排序（heap-sort）  
    先构建一个堆，通过循环对N/2到1的元素以此sink（。。。），   构建了一个大（小）顶堆，然后再将堆顶元素和最后一个元素交换，sink（1） 调整，N--，直到N>1                                         
    结束。排序完成。  
    堆排序是目前唯一的能够同时最优的利用空间和时间的排序。即使在最坏的情况下也能保证使用2NlgN次比较和恒定的额外空间，
    但是现在的系统很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素比较，因此缓存的未命中次数要远远高于其他和相邻元素比较的算法，如快排，归并排序
    甚至希尔排序。

### 各项排序算法时间复杂度
![image](http://od4ghyr10.bkt.clouddn.com/sortalgo/%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93.jpg)  
图片来自http://blog.chinaunix.net/uid-21457204-id-3060260.html
