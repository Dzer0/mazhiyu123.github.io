--
published: true
layout: post
title: 算法设计策略-动态规划(DP)
category: 算法设计策略
tags: 
  - 算法设计策略
time: 2017.02.15 12:02:00
excerpt: 动态规划是一种算法设计策略,通常是用来求解问题的最优解.它和分治设计策略有些类似.分治策略是通过迭代将问题分解为多个子问题,各个子问题相互独立,分别求解然后将子问题的解合并就是原始问题的解.而动态规划也会将原始问题分解为子问题但是认为子问题之间是有联系的,不同的是它是通过迭代方式,通过计算得出最优解的结构,自底向上计算出问题的最优解. 
---

#### 动态规划
动态规划是一种算法设计策略，通常是用来求解问题的最优解。它和分治设计策略有些类似。分治策略是通过迭代将问题分解为多个子问题，各个子问题相互独立，分别求解然后将子问题的解合并就是原始问题的解。而动态规划也会将原始问题分解为子问题但是认为子问题之间是有联系的，不同的是它是通过迭代方式，通过计算得出最优解的结构，自底向上计算出问题的最优解。  
动态规划的基本步骤
1. 确定最优解的结构。
2. 递归定义最优解的值。
3. 自底向上计算解的值。（通过迭代）
4. 利用计算得到的信息构造最优解。
可以利用动态规划解决的问题，面值问题，装配线问题，0-1背包问题，矩阵链乘问题，最长公共子序列，最长非降子序列问题等。  

一．面值问题  
问题描述：有面值为1元5元10元的零钱，如何用最少的零钱数量达到某一指定金额，比如达到20元只需要两张10元即可。用d(i)表示达到金额i所需要的零钱数量。如d(0)=0,d(4)=4,d(5)=1.
缩小问题的规模，想要达到金额i先从0开始逐渐到i。  
```
d(0)=0;
d(1)=1;
d(2)=d(2-1)+1=1+1=2;
d(3)=d(3-1)+1=2+1=3;
d(4)=d(4-1)+1=3+1=4;
d(5)=min{ d(5-1)+1, d(5)}=min{5,1}=1;(此时面值为5的零钱可以使用)
d(6)=min{ d(6-1)+1, d(6-5)+1}=min{1+1,1+1}=2;
d(7)=min{ d(7-1)+1,d(7-5)+1}=min{3,3}=3;
....
d(i)=min{ d{i-Vn}+1},其中Vn为到目前i为止，所能使用的零钱的面值。
```
上面的式子就是递归的定义了最优解的值。  

二．装配线问题  
问题描述：有两条并行的装配线line1和line2每条装配线上有n个工作站，Si,1 -- Si,n 其中i=1 或2.  
对于每个j, S1, j 与 S2, j对应的工作站做的是相同工作，但 是花费不同的时间，用aij表示。  
从第i条装配线j工作站迁移到另一条装配线花费的时间为tij
上装配线的时间为ei，下装配线的时间为xi  其中i=1 或2.
找到最快通过装配线的方式。  
![image](http://od4ghyr10.bkt.clouddn.com/DP-1.png)  
假设从站S1,j出站  
1. 如果j=1,只有一种情况  
2. 如果j>=2,有两种情况  
    1. S1,j的上一站是从line1，j-1站出来的，即S1,j-1
    2. S1,j的上一站是从line2，j-1站出来，即S2,j-1，然后迁移到line1的。  

S1,j的最优解包含其子问题的最优解即S1,j-1和S2,j-1的最优解

fi[j]表示从Si,j站出来的最短时间  
![image](http://od4ghyr10.bkt.clouddn.com/DP-2.png)  
由对称性质  
![image](http://od4ghyr10.bkt.clouddn.com/DP-3.png)  


三．0-1背包问题  
问题描述：容量为C的背包，n个价值为v，重量为w的商品，如何装商品才能取得最大的价值。（商品要么装要么不装不能只装一部分）对于一个商品只有两种状态装入了背包和没有装入背包。（对于分数背包问题，计算出每个物品的价值然后从大到小排序即可）向背包中依次装商品，改变容量和价值。  

V(i,j)表示前i个商品能够装入容量为j的背包中的最大价值。  

V（i，j）=V(i-1,j) j<wi :此式子表明若第i个商品的重量wi大于背包的容量j则前i个商品可以装入背包的最大价值等于前i-1个商品装入背包取得的最大价值。此时，商品i不能装入背包。 

V（i，j）=max{ V(i-1,j) ,V(i-1,j-wi)+vi) }  j>wi  （j的初始值为背包的容量然后加商品减容量）  
:V(i-1,j)第i个商品没有装入背包，背包中物品价值就等于把前i-1个物品装入容量为j的背包中所取得的价值。  
:V(i-1,j-wi)+vi 第i个商品装入了背包。前i-1个商品装入容量为j-wi的背包中最大价值加上第i个商品的价值。  

四．矩阵链乘问题  
问题描述：有A1。。。An个矩阵，如何相乘才能使相乘运算的次数最少。  
可以理解为在A1。。。An中加括号。  
假设A[i:j]表示i到j段相乘，其最优解在k处断开，则A[i:k]和A[k+1:j]也是相应矩阵相乘段的最优解。  
m[i:j]表示i到j的最优解，则有  
![image](http://od4ghyr10.bkt.clouddn.com/DP-4.png)  


五．最长公共子序列  
问题描述：求两个字符串序列的最长公共子序列，所求解的子序列的字符可以不是连续的。  
关注的是参与对比的两个字符串序列的前缀，从字符序列的最后开始向前比较每个字符状态有在最长公共子序列内和不再最长公共子序列内两种状态。  
递归最优解的值：  
```
C[i,j] = { c[i-1,j-1]+1         当 i，j>0且Xi=Yi }   ---(1)
         { Max{ c[i-1,j] , c[i,j-1]  otherwise   }   ---(2)
（1）当第i个字符相等的时候，则最长公共子序列+1，然后比较前i-1个字符序列
（2）当第i个字符不相等的时候，则比较x字符序列的前i-1个和y字符序列前j-1个字符序列前缀个数，选择大的那个。
```


六．最长非降子序列问题  
问题描述:在一串序列中找到最长的非降子序列，（连续的）  
这个问题和最长公共子序列的思路是一样的，区别就是这里要求子序列是连续的。每个字符有两种状态，在最长非降子序列中，和不在其中。  
递归最优解的值  
```
d(j)={ max{ 1，d(j-1)+1 } }
```

备忘录算法  
一般的动态规划算法都是自底向上计算解决问题的。备忘录算法是动态规划算法的另一种形式，它保留了自上而下的形式。  
它是在递归算法的基础上添加了备忘录，用这个备忘录记录每个子问题已经计算出来的最优解。这样避免了以后再用到这个子问题的重复计算问题。  

自底向上的动态规划方法  
要得出问题的最优解必须求解出所有子问题的解，标准访问形式可以有效减少计算所需要的时间和所需要的空间。  
自上而下递归+备忘录  
在递归的过程会通过判定条件排出掉一些不需要递归调用的情况，所以不需要求解出每个子问题的解，递归调用需要的存储空间会比较大。  